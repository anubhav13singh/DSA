<aside>
    ğŸ’¡ **Question 3**
    
    There is an integer arrayÂ `nums`Â sorted in ascending order (withÂ **distinct**Â values).
    
    Prior to being passed to your function,Â `nums`Â isÂ **possibly rotated**Â at an unknown pivot indexÂ `k`Â (`1 <= k < nums.length`) such that the resulting array isÂ `[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]`Â (**0-indexed**). For example,Â `[0,1,2,4,5,6,7]`Â might be rotated at pivot indexÂ `3`Â and becomeÂ `[4,5,6,7,0,1,2]`.
    
    Given the arrayÂ `nums`Â **after**Â the possible rotation and an integerÂ `target`, returnÂ *the index of*Â `target`Â *if it is in*Â `nums`*, or*Â `-1`Â *if it is not in*Â `nums`.
    
    You must write an algorithm withÂ `O(log n)`Â runtime complexity.
    
    **Example 1:**
    
    ```
    Input: nums = [4,5,6,7,0,1,2], target = 0
    Output: 4
    
    ```
    
    **Example 2:**
    
    ```
    Input: nums = [4,5,6,7,0,1,2], target = 3
    Output: -1
    
    ```
    
    **Example 3:**
    
    ```
    Input: nums = [1], target = 0
    Output: -1
    ```
    
    **Explanation :** 
    
    - The Binary search approach is based on the fact that a rotated sorted array can be divided into two sorted arrays.
        1. The approach starts with finding the mid element and compares it with the target element.
        2. If they are equal, it returns the mid index. If the left half of the array is sorted, then it checks if the target lies between the start and the mid, and updates the end pointer accordingly.
        3. Otherwise, it checks if the target lies between mid and end, and updates the start pointer accordingly.
        4. If the right half of the array is sorted, then it checks if the target lies between mid and end, and updates the start pointer accordingly.
        5. Otherwise, it checks if the target lies between start and mid, and updates the end pointer accordingly.
        6. This process continues until the target element is found, or the start pointer becomes greater than the end pointer, in which case it returns -1.
        7. This approach has a time complexity of O(log n).
    
    # **Complexity:**
    
    - Time Complexity:
        
        The time complexity of the Binary search approach is O(log n), where n is the size of the input array.
        
    - Space Complexity:
        
        The space complexity of both approaches is O(1) as we are not using any extra space to store any intermediate results.
        
    </aside>
    <script>
        function search(nums,target){
            s = 0;
            e = nums.length-1;
            mid = Math.floor((s+e)/2);
            while(s<=e){
                if( target == nums[mid]){
                    return mid;
                }
                // if left side is sorted
                if( nums[s] <= nums[mid]){
                    if( nums[s] <= target && num[mid] >= target){
                        e = mid - 1;
                    }
                    else{
                        s = mid +1;
                    }
                }else{// if right side is sorted
                    if(nums[e] >= taget && nums[mid]<= target) {
                        s = mid +1;
                    }else{
                        e = mid -1;
                    }
                }
            }
             return -1; 
        }

    </script>